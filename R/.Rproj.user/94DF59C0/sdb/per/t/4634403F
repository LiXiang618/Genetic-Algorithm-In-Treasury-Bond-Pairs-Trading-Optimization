{
    "contents" : "setwd(\"D:/百度云/My Box Files/SAIF/论文/2015/强化学习/SourceCode/Good/rlpy-master/examples/Pairtrading/R\")\nload.library <- function(package_name) {\n  package_name <- as.character(match.call()[[2]])\n  if (!require(package_name, character.only = T)) {\n    install.packages(package_name)\n    require(package_name)\n  }\n}\n####### FUNCTION DEFINITIONS #######\n\nload.library(\"plyr\")\nload.library(\"foreach\")\nload.library('doParallel')\nload.library(\"ggplot2\")\nload.library(\"tseries\")\nload.library(\"xts\")\nload.library(\"quantmod\")\nload.library(\"PerformanceAnalytics\")\nload.library(\"assertthat\")\nload.library(\"mongoquery\")\nload.library(\"data.table\")\nload.library(\"lubridate\")\nload.library(\"pipeR\")\nsource(\"func.R\")\nsource(\"Cointegration.R\")\nsource(\"PairTrading.R\")\nsource(\"Signal.R\")\n\ntraceback()\nself <- list()\nself$day <- double()    #当前日期\n#self$price.pair <- NA  #配对价格\nself$sample <- NA       #测试集\nself$signals <- NA      #保存开仓信号\nself$weight <- NA       #beta\nself$zscore <- NA       #zscore\n\nself$entry <- NA\nself$stoploss <- NA\n\nself$zscore.pre <- NA\n\nself$beta <- NA\nself$premium <- NA\nself$reward <- 0\n\n#self$in.sample <- NA   #测试集合\n#self$out.sample <- NA  #验证集合\n\n#status define\nOPENED <- 0L\nCLOSED <- 1L\nTERMINAL <- 2L\n\nself$assets.id = array(dim = 2,dimnames = c(\"Left\",\"Right\"))\n\ninit <- function(assets,bExploratio) {\n  self$assets.id <<- assets\n  date.duration <- c(as.POSIXct('2003-06-01'), as.POSIXct('2016-02-04'))\n  print(assets)\n  print(date.duration)\n  \n  price.pair <- GetAssetsData('CFETS', self$assets.id, date.duration)\n  sample.num <- nrow(price.pair)\n  in.sample <- price.pair[1:round(sample.num*2/3),]\n  out.sample <- price.pair[(round(sample.num*2/3) -200):sample.num,]\n  \n  if (bExploratio) {\n    self$sample <<- in.sample\n  }\n  else{\n    self$sample <<- out.sample\n  }\n}\n\n#初始化每次epeson\ns0 <- function(beginDay)\n{\n  self$day <<- beginDay\n  self$signals <<-\n    xts(array(NA, dim = nrow(self$sample)), order.by = index(self$sample))\n  self$zscore <<-\n    xts(array(NA, dim = nrow((self$sample))), order.by = index(self$sample))\n  num.price <- nrow(self$sample)\n  self$weight <<-\n    xts(data.frame(p1 = rep(0, num.price), p2 = rep(0, num.price)), order.by = index(self$sample))\n  \n  self$entry <<- xts(array(NA, dim = num.price), order.by = index(self$sample))\n  self$stoploss <<- xts(array(NA, dim = num.price), order.by = index(self$sample))\n  \n  self$beta <<- xts(array(NA, dim = num.price), order.by = index(self$sample))\n  self$premium <<- xts(array(NA, dim = num.price), order.by = index(self$sample))\n  self$reward <<- 0\n}\n\n\n# Inputs:\n#   s: state, represented by an array of integers\n#   s[1] 0\n#   s[2] 0\n#   s[3] == 1,end;\n#   a: action\n#    a[1] esimate period\n#    a[2] entryZscore\n#    a[3] stoplossZscore\n#    a[4] trading window\n# output:\n# list of:\n#   new state\n#   reward\n\n.step <- function(context, status, a)\n{\n  # if terminal state, exit gracefully\n  if (status[1] == TERMINAL)\n    return(list(context,status,0))\n  \n  new.s <- status\n  num.days <- nrow(context$sample)\n  if (context$day >= num.days) {\n    new.s[1] <- TERMINAL\n    return(list(context,status,0))\n  }\n  # both new state and reward will be returned\n\n  reward <- 0L\n  \n  oldSignal <- 0\n  zScore.pre <- context$zscore.pre\n  #parameter setting\n  params.period <- a[1]\n  params.tradingwindow <- a[2]\n  params.entryZscore <- a[3]\n  params.stoplossZscore <- a[4]\n  params.exitZscore <- 0\n  \n  if (params.period < params.tradingwindow || params.entryZscore > params.stoplossZscore) {\n    new.s[1] <- TERMINAL\n    return(list(context,status,-10))\n  }\n  \n  context$entry[index(context$sample[context$day])] <- params.entryZscore\n  context$stoploss[index(context$sample[context$day])] <- params.stoplossZscore\n  \n  openDay <- 0\n  \n  \n  while (context$day <= num.days) {\n    rolldayPrice <-\n      context$sample[(context$day - params.period + 1):context$day,]\n    reg <- EstimateParameters(rolldayPrice, method = lm)\n\n    meanSpread <- mean(na.omit(reg$spread))\n    stdSpread <- sd(na.omit(reg$spread))\n    \n    zScore <- (reg$spread - meanSpread) / stdSpread\n    zScore.last <- xts::last(zScore)\n    context$zscore[index(zScore.last)] <- zScore.last\n    context$beta[index(zScore.last)] <- xts::last(reg$hedge.ratio)\n    context$premium[index(zScore.last)] <- xts::last(reg$premium)\n    \n    signal <- DaySignal(zScore.last, zScore.pre, params.entryZscore, params.stoplossZscore)\n    zScore.pre <- zScore.last\n    # exceed trading window, close position\n    if (oldSignal != 0 &&\n        (is.na(signal) ||\n         signal == oldSignal) &&\n        (context$day - openDay) >= params.tradingwindow) {\n      signal <- 0\n    }\n    \n    if (!is.na(signal)) {\n      context$signals[index(zScore.last)] <- signal\n    }\n    # open position\n    # 3-19 NOTE: 0 1 -1, will miss middle 1\n    if (!is.na(signal) && signal != oldSignal && signal != 0) {\n      #browser()\n      status[1] <- OPENED\n      openDay <-  context$day\n      weight <- HedgeRatio2Weight(reg$hedge.ratio)\n    }\n    # close position\n    # 3-19 NOTE: 1 1 -1, will miss close position of long\n    if (!is.na(signal) && signal != oldSignal && signal == 0) {\n      context$day <- context$day + 1\n      status[1] <- CLOSED\n      \n      window.current <- context$day - openDay + 1\n      effect.price <- context$sample[openDay:context$day, ]\n      price.return <- na.omit(Return.calculate(effect.price))\n      weights <- xts(matrix(rep(weight*c(-oldSignal, oldSignal), each = window.current), nrow = window.current), order.by = index(effect.price))\n      portfolio.return <- Return.portfolio(price.return, weights = lag(weights), geometric = F)\n      context$weight[index(weights),] <- weights\n      reward <- SortinoRatio(portfolio.return) \n      if (reward[1] == Inf) {\n        reward[1] = 0\n      }\n      reward <- reward[1] %>>% \n      atan  %>>%\n      round(4)\n      #browser()\n      context$zscore.pre <- zScore.last\n      \n      return(list(context,new.s,reward))\n    }\n    if (!is.na(signal))\n      oldSignal <- signal\n    \n    context$day <- context$day + 1\n  }\n  # at last close all position\n  if (oldSignal != 0)\n    context$signals[context$day - 1] <- 0\n  new.s[1] <- TERMINAL\n  # whole reward\n  \n  whole.price.return <- na.omit(Return.calculate(context$sample))\n  whole.return <- Return.portfolio(whole.price.return, weights = lag(context$weight), geometric = F)\n  tmp.table <- data.table(cbind(whole.return, year(index(whole.return)), month(index(whole.return))))\n  names(tmp.table) <- c(\"portfolio.return\", \"year\", \"month\")\n  month.return <- tmp.table[,sum(portfolio.return), by=.(year, month)]\n  month.timestamps <- as.Date(month.return[,paste(year, month, \"01\", sep=\"-\")])\n  whole.reward <-SortinoRatio(month.return[,V1])[1] %>>%\n  atan %>>%\n  round(4)\n  #whole.reward <- round(SharpeRatio(xts(month.return[,V1], order.by = month.timestamps)), 4)\n  cat(\"whole.reward:\",whole.reward,\"\\r\\n\")\n  return(list(context, new.s, whole.reward))\n}\n\n\n# Inputs:\n#   s: state\n#   s[0]:\n#       0:OPENED\n#       1:CLOSED\n#       2:TERMINAL\n#   a: action\n#    a[1] esimate period\n#    a[2] trading window\n#    a[3] entryZscore\n#    a[4] stoplossZscore\n# output:\n# list of:\n#   new state\n#   reward\n\nstep <- function(status, a)\n{\n  ret <- .step(self,status,a)\n  #ret <- .steptest(self,status,a)\n  # print(system.time(ret <- .step(self,status,a)))\n  self <<- ret[[1]]\n  return(c(ret[[2]][1],ret[[3]][1]))\n}\n.steptest <- function(context, status, a)\n{\n  # if terminal state, exit gracefully\n  if (status[1] == TERMINAL)\n    return(list(context,status,0))\n  \n  new.s <- status\n  num.days <- nrow(context$sample)\n  if (context$day >= num.days) {\n    return(list(context,status,-1.0))\n    \n  }\n  reward <- 0L\n  \n  oldSignal <- 0\n  zScore.pre <- context$zscore.pre\n  #parameter setting\n  params.period <- a[1]\n  params.tradingwindow <- a[2]\n  params.entryZscore <- a[3]\n  params.stoplossZscore <- a[4]\n  params.exitZscore <- 0\n  \n  if (params.period < params.tradingwindow || params.entryZscore > params.stoplossZscore) {\n    return(list(context,status,-1.0))\n  }\n  \n  context$entry[index(context$sample[context$day])] <- params.entryZscore\n  context$stoploss[index(context$sample[context$day])] <- params.stoplossZscore\n  \n  openDay <- 0\n  while (context$day <= num.days) {\n    if (!(context$day %% 300)) {\n      context$day <- context$day + 1\n      reward =log(params.period**2 + params.tradingwindow*params.entryZscore + sqrt(params.stoplossZscore))\n      context$reward = reward + context$reward\n      return(list(context, new.s, reward))\n    \n    }\n    context$day <- context$day + 1\n  }\n  new.s[1] <- TERMINAL\n  return(list(context, new.s, context$reward))\n  \n}\nshowDomain <- function(show = TRUE)\n{\n  if(show){\n  price.return <- na.omit(Return.calculate(self$sample))\n  portfolio.return <- Return.portfolio(price.return, weights = lag(self$weight), geometric = F)\n  print(c(maxDrawdown=maxDrawdown(portfolio.return), SortinoRatio=SortinoRatio(portfolio.return), Return.annualized=Return.annualized(portfolio.return)))\n  \n  signals <- na.omit(na.locf(self$signals))\n  PlotAssets(self$sample, self$assets.id)\n  \n  PlotWithSignalFloatEntry(self$zscore, signals, self$entry, 0, self$stoploss)\n  # PlotWithSignal(self$zscore, signals, self$entry, 0, self$stoploss)\n  \n  price.return <- Return.calculate(self$sample)\n  portfolio.return <- Return.portfolio(na.omit(price.return), weights = lag(self$weight), geometric = F)\n  charts.PerformanceSummary(portfolio.return)\n  \n  PlotBetaAndPremium(self$beta, self$premium)\n  }\n  .save()\n}\n.save <- function()\n{\n  f_continue <- function(prompt = \"Do you want to save the result? (y/n)\") {\n    return( TRUE )\n    n <- readline(prompt=prompt)\n    n <- as.character(n)\n    if (n == 'y')\n      return( TRUE )\n    else\n      return( FALSE )\n  }\n  if (f_continue()) {\n    name <- paste(self$assets.id[1],self$assets.id[2],'_result.RData',sep = \"\")\n    save(self, file=name)\n  }\n}\n.load <- function(assets)\n{\n  name <- paste(assets[1],assets[2],'_result.RData',sep = \"\")\n  load(name)\n  return (self)\n}\n\nmain <- function(){\n  assets.id <- c('GZ3Y', 'GZ5Y')\n  init(assets.id, TRUE)\n  s0(200)\n  status <- c(CLOSED)\n  sample.entry <- rep(c(0.5, 0.6, 0.7, 1, 0.5, 0.6, 0.7, 0.5, 0.6, 0.7), 20)\n  sample.stoploss <- rep(c(3.2, 2.9, 3, 3.5, 3.9, 4.9, 4.1, 3.1, 3.3, 3.4), 20)\n  a <- c(200, 70, 0.5, 3.1)\n  #trace(.step, exit = quote(if (reward[1] == Inf) browser()))\n  Rprof(\"Rprof.log\")\n  while (status[1] != TERMINAL) {\n    # performing step\n    #a <- c(200, 150, sample.entry[randi(c(1,200), 1, 1)], sample.stoploss[randi(c(1,200), 1, 1)])\n    tmp <- step(status, a)\n    status <- tmp[1]\n    r <- tmp[2]\n    print(c(status[1],self$day - 1, self$signals[self$day - 1],self$zscore[self$day - 1],r))\n  }\n  Rprof(NULL)\n  showDomain()\n}\n",
    "created" : 1456744419949.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2138161876",
    "id" : "4634403F",
    "lastKnownWriteTime" : 1457614263,
    "path" : "D:/百度云/My Box Files/SAIF/论文/2015/强化学习/SourceCode/Good/rlpy-master/examples/Pairtrading/R/script.R",
    "project_path" : "script.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : true,
    "type" : "r_source"
}