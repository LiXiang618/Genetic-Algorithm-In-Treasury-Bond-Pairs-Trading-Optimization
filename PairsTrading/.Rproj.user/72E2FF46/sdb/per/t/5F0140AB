{
    "contents" : "Simple <- function(spread, spread.entry)\n{\n  signal <- ifelse(spread >=   spread.entry, -1, NA)\n  signal <- ifelse(spread <=  -spread.entry,  1, signal)\n  return(na.locf(signal))\n}\nSimpleWithTakeProfit <- function(spread, spread.entry, spread.take.profit)\n{\n  signal <- ifelse(spread >=   abs(spread.entry), -1, 0)\n  signal <- ifelse(spread <=  -abs(spread.entry),  1, signal)\n  \n  take.profit.upper <-  abs(spread.take.profit)\n  take.profit.lower <- -take.profit.upper\n\n  #Hit take.profit line : 0\n  #other case : continue previous position\n  for(i in 2:nrow(signal))\n  {\n    if(signal[i] == 0){\n      if(signal[i - 1] == 1){\n        if(spread[i] >= take.profit.lower){\n          signal[i] <- 0\n        }else{\n          signal[i] <- signal[i - 1]\n        }\n      }else if(signal[i - 1] == -1){\n        if(spread[i] <= take.profit.upper){\n          signal[i] <- 0\n        }else{\n          signal[i] <- signal[i - 1]          \n        }\n      }\n    }\n  }\n  return(signal)\n}\nSignalWithZscore <- function(spreadZscore, entryZscore,stoplossZscore = NA)\n{\n  signal <- ifelse(spreadZscore >=   entryZscore, -1, NA)\n  signal <- ifelse(spreadZscore <=  -entryZscore,  1, signal)\n  if (is.na(stoplossZscore))   return(na.locf(signal))\n\n  stoplossZscore.upper <-  abs(stoplossZscore)\n  stoplossZscore.lower <- -stoplossZscore\n\n  #Hit take.profit line : 0\n  #other case : continue previous position\n  for(i in 2:nrow(signal))\n  {\n    if(signal[i] == 0){\n      if(signal[i - 1] == 1){\n        if(spreadZscore[i] >= stoplossZscore.lower){\n          signal[i] <- 0\n        }else{\n          signal[i] <- signal[i - 1]\n        }\n      }else if(signal[i - 1] == -1){\n        if(spreadZscore[i] <= stoplossZscore.upper){\n          signal[i] <- 0\n        }else{\n          signal[i] <- signal[i - 1]          \n        }\n      }\n    }\n  }\n  return(signal)\n\n}\n\n#return:\n#  -1 Short Open\n#  1 Long Open\n#  0 Close\n#  NA DoNothing\nDaySignal <- function(zscore.current, old.zscore, entryZScore, stopLossZScroe){\n  if(is.na(old.zscore)){\n    if(zscore.current > entryZScore){\n      return(-1)\n    }else if(zscore.current < -entryZScore){\n      return(1)\n    }else{\n      return(NA)\n    }\n  }\n  if(old.zscore < entryZScore && zscore.current > entryZScore){\n    return(-1)\n  }\n  if(old.zscore > -entryZScore && zscore.current < -entryZScore){\n    return(1)\n  }\n  if(old.zscore > 0 && zscore.current < 0){\n    return(0)\n  }\n  if(old.zscore < 0 && zscore.current > 0){\n    return(0)\n  }\n  if(old.zscore < stopLossZScroe && zscore.current > stopLossZScroe){\n    return(0)\n  }\n  if(old.zscore > -stopLossZScroe && zscore.current < -stopLossZScroe){\n    return(0)\n  }\n  return(NA)\n}\n\nTestDaySignal <- function(){\n  #test DaySignal\n  assert_that(is.na(DaySignal(1.5, 0, 2,3)))\n  assert_that(DaySignal(2.1, 0, 2,3) == -1)\n  assert_that(DaySignal(3.1, -1, 2,3) == 0)\n  assert_that(DaySignal(2.5, 0, 2,3) == -1) #here is error\n  assert_that(is.na(DaySignal(1.8, -1, 2,3)))\n  assert_that(DaySignal(0, -1, 2,3) == 0)\n  assert_that(DaySignal(-2.0, 0, 2,3) == 1)\n  assert_that(DaySignal(-3.0, 1, 2,3) == 0)\n  assert_that(DaySignal(-2.5, 0, 2,3) == 1)\n  assert_that(DaySignal(0.1, 1, 2,3) == 0)\n}\n\nPlotWithSignal <- function(zscore, signal, zscore.entry=1.5, zscore.exit=0, zscore.stoploss=2.5){\n  data.comb <- na.omit(cbind(zscore, signal))\n  zscore <- data.comb[, 1]\n  signal <- data.comb[, 2]\n  timestamps <- index(zscore)\n  zScoreDiagramString <- paste('Strategy (Zscore entry above/below ',zscore.entry, ' std, Zscore exit below/above ', zscore.exit, ' std)', sep=\"\")\n  plot(timestamps, zscore, xlab=\"Time\", ylab=\"Zscore\", main=zScoreDiagramString, type=\"l\")\n  lim <- par(\"usr\")\n  beginRect <- 1\n  endRect <- 1\n  signal.length <- length(signal)\n  for(i in 2:(signal.length - 1))\n  {\n    # Begin long position\n    if(signal[i]==1 && signal[i-1]==0){\n      beginRect <- i\n    }\n    # Begin short position\n    if(signal[i]==-1 && signal[i-1]==0){\n      beginRect <- i\n    }\n    # End long position\n    if(signal[i]==0 && signal[i-1]==1){\n      rect(timestamps[beginRect], lim[3]-1, timestamps[i], -zscore.exit, col = \"green\")\n    }\n    # End short position\n    if(signal[i]==0 && signal[i-1]==-1){\n      rect(timestamps[beginRect], zscore.exit, timestamps[i], lim[4]+2, col = \"red\")\n    }\n  }\n  \n  if(signal[signal.length] == 1 && signal[signal.length-1] == 1){\n    rect(timestamps[beginRect], lim[3]-1, timestamps[signal.length], -zscore.exit, col = \"green\")\n  }else if(signal[signal.length] == -1 && signal[signal.length-1] == -1){\n    rect(timestamps[beginRect], zscore.exit, timestamps[signal.length], lim[4]+2, col = \"red\")\n  }\n  lines(timestamps, zscore)\n  abline(h=c(-zscore.entry,zscore.entry,-zscore.exit,zscore.exit,-zscore.stoploss,zscore.stoploss),col=c(\"blue\",\"blue\",\"red\",\"red\",\"green\",\"green\"))\n}\n\n\n\n#start from 100 day\ns.ini <- function () {\n  return ( c(0L,0L, 0L))\n}\n# Inputs:\n#   s: state, represented by an array of integers\n#   s[1] 0\n#   s[2] 0\n#   s[3] == 1,end;\n#   a: action\n#    a[1] esimate period\n#    a[2] entryZscore\n#    a[3] stoplossZscore\n#    a[4] trading window\n# output:\n# list of:\n#   new state\n#   reward\nold.zscore <<- NA\nSetp <- function(price.pair, s, a)\n{\n  # if terminal state, exit gracefully\n  if(s[3] == 1)\n    return(list(0L,s))\n\n  # both new state and reward will be returned\n  new.s <- s\n  reward <- 0L\n\n  oldSignal <- 0\n\n  params.period <- a[1]\n  params.entryZscore <- a[2]\n  params.exitZscore <- 0\n  params.stoplossZscore <- a[3]\n  openDay <- 0\n  params.tradingwindow <- a[4]\n\n  #lastday <- s[0]\n  #setpDone <- F\n  num.days <- nrow(price.pair)\n  \n  while(day <= num.days){\n    rolldayPrice <- price.pair[(day - params.period + 1) : day, ]\n    reg <- EstimateParameters(rolldayPrice, method = lm)\n    meanSpread <- mean(na.omit(reg$spread))\n    stdSpread <- sd(na.omit(reg$spread))\n    \n    zScore <- (reg$spread - meanSpread) / stdSpread\n    zScore.last <- last(zScore)\n    pair.zscore[index(zScore.last)] <<- zScore.last\n    \n    signal <- DaySignal(zScore.last, old.zscore, params.entryZscore, params.stoplossZscore)\n    old.zscore <<- zScore.last\n    # exceed trading window, close position\n    if(oldSignal != 0 && (is.na(signal) || signal==oldSignal) && (day - openDay) >= params.tradingwindow){\n      signal <- 0\n    }\n    \n    if(!is.na(signal)){\n      signals[index(zScore.last)] <<- signal\n    }\n    # open position\n    if (!is.na(signal) && signal != oldSignal && signal != 0) {\n      openDay <-  day\n      weight <- HedgeRatio2Weight(reg$hedge.ratio)\n    }\n    if (!is.na(signal) && signal != oldSignal && signal == 0) {\n      # setpDone <- TRUE\n      day <<- day + 1\n      s[3] <- 0\n      # reward\n      window.current <- day - openDay + 1\n      effect.price <- price.pair[openDay:day, ]\n      price.return <- na.omit(Return.calculate(effect.price))\n      weights <- xts(matrix(rep(weight*c(-oldSignal, oldSignal), each = window.current), nrow = window.current), order.by = index(effect.price))\n      portfolio.return <- Return.portfolio(price.return, weights = lag(weights), geometric = F)\n      whole.weight[index(weights),] <<- weights\n      reward <- SortinoRatio(portfolio.return)\n      # print(reward)\n      return (c(reward , s))\n    }\n    if(!is.na(signal)) oldSignal <- signal\n    \n    day <<- day + 1\n  }\n  # at last close all position\n  if(oldSignal!=0) signals[day-1] <<- 0\n  s[3] <- 1\n  # whole reward\n  return (c(reward,s))\n}\n",
    "created" : 1456375447788.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "987347627",
    "id" : "5F0140AB",
    "lastKnownWriteTime" : 1456575675,
    "path" : "C:/QuantPlatfrom/pairtrading_base/PairsTradingForRLWK0.1/Signal.R",
    "project_path" : "Signal.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}