{
    "contents" : "Return <- function(price.pair, signal.lagged, hedge.ratio.lagged)\n  # 从开仓到平仓的价格[]，开仓信号[]，开仓时的hedge.ratio\n{\n  #\n  signal      <- as.xts(na.omit(cbind(signal.lagged, -1*(signal.lagged))))\n  return.pair <- as.xts(na.omit(.return(price.pair, type = \"discrete\")))\n  weight.pair <- as.xts(na.omit(HedgeRatio2Weight(hedge.ratio.lagged)))\n  #\n  #names(return.pair) <- names(price.pair)\n  #names(signal)      <- names(price.pair)\n  #names(weight.pair) <- names(price.pair) \n  #as.xts(apply(signal * weight.pair * return.pair, 1, sum) * leverage)\n  x <-          as.xts(apply(merge(signal[, 1], weight.pair[, 1], return.pair[, 1], all = FALSE), 1, prod))\n  x <- merge(x, as.xts(apply(merge(signal[, 2], weight.pair[, 2], return.pair[, 2], all = FALSE), 1, prod)))\n\n  if(!length(dim(x))){\n    xts(rep(NA, nrow(price.pair)), order.by = index(price.pair))\n  }else{\n    xts(rowSums(x), order.by = index(x))\n  }\n}\n\n.return <- function(x, type = c(\"continuous\", \"discrete\"), na.pad = TRUE) \n{\n    type <- match.arg(type)\n    if (type == \"discrete\") {\n        result <- x/lag(x, na.pad = na.pad) - 1\n    }else if (type == \"continuous\") {\n        result <- diff(log(x), na.pad = na.pad)\n    }\n    return(result)\n}\n\nPlotAllGraph <- function(zscore){\n  zscore <- na.omit(zscore)\n  signal <- SignalWithZscore2(zscore, params.entryZscore, params.exitZscore, params.stoplossZscore)\n}\n\nSignalWithZscore2 <- function(zscore.spread, zscore.entry=1.5, zscore.exit=0, zscore.stoploss=2.5){\n  zscore.spread <- na.omit(zscore.spread)\n  timestamps <- index(zscore.spread)\n  longs.entry <- (zscore.spread < -zscore.entry)\n  longs.exit <- (zscore.spread > -zscore.exit)\n  longStopLoss.exit <- (zscore.spread < -zscore.stoploss)\n  shorts.entry <- (zscore.spread > zscore.entry)\n  shorts.exit <- (zscore.spread < zscore.exit)\n  shortStopLoss.exit <- (zscore.spread > zscore.stoploss)\n  \n  spread.number <- length(zscore.spread)\n  # Create vector with 0 values\n  units.long <- vector(mode=\"numeric\", length=spread.number)\n  # Set NA from 2:end\n  # first of units.long has value within processing above\n  # if no value, then its initial value = 0\n  units.long[2:spread.number] <- NA\n  units.short <- units.long # Copy by value\n  \n  # numUnitsLong represents an array with 1 entrys on positions where we are long the portfolio spread\n  units.long[longs.entry] <- 1;\n  units.long[longs.exit] <- 0\n  units.long[longStopLoss.exit] <- 0\n  units.long <- na.locf(units.long)\n  \n  # numUnitsShort represents an array with -1 entrys on positions where we are short the portfolio spread\n  units.short[shorts.entry] <- -1\n  units.short[shorts.exit] <- 0\n  units.short[shortStopLoss.exit] <- 0\n  units.short <- na.locf(units.short)\n  \n  # numUnits represents an array that indicates how many units of the portfolio spread we bought (1), or sold (-1)\n  units.pos <- units.long + units.short\n  \n  # Plot standardizedSpread\n  zScoreDiagramString <- paste('Strategy (Zscore entry above/below ',zscore.entry, ' std, Zscore exit below/above ', zscore.exit, ' std)', sep=\"\")\n  plot(timestamps, zscore.spread, xlab=\"Time\", ylab=\"Standardized Spread\", main=zScoreDiagramString, type=\"l\")\n  lim <- par(\"usr\")\n  beginRect <- 1\n  endRect <- 1\n  pos.length <- length(units.pos)\n  signal <- rep(NA, pos.length)\n  signal[1] <- 0\n  # uptick strategy\n  for(i in 2:(pos.length-1))\n  {\n    # Begin long position\n    if(units.pos[i]==1 & units.pos[i-1]==0){\n      beginRect <- i\n      signal[i] <- 1\n    }\n    # Begin short position\n    if(units.pos[i]==-1 & units.pos[i-1]==0){\n      beginRect <- i\n      signal[i] <- -1\n    }\n    # end long position when timeout\n    if(units.pos[i] == 1 && as.numeric(timestamps[i] - timestamps[beginRect]-max.duration)*as.numeric(timestamps[i-1] - timestamps[beginRect]-max.duration) <= 0){\n      rect(timestamps[beginRect], lim[3]-1, timestamps[i-1], -zscore.exit, col = \"green\")\n      signal[i] <- 0\n\n    }\n    # end short position when timeout\n    if(units.pos[i] == -1 && as.numeric(timestamps[i] - timestamps[beginRect]-max.duration)*as.numeric(timestamps[i-1] - timestamps[beginRect]-max.duration) <= 0){\n      rect(timestamps[beginRect], zscore.exit, timestamps[i-1], lim[4]+2, col = \"red\")\n      signal[i] <- 0\n    }\n    # End long position\n    if(units.pos[i]==0 && units.pos[i-1]==1 && (timestamps[i] - timestamps[beginRect]) < max.duration){\n      # browser()\n      rect(timestamps[beginRect], lim[3]-1, timestamps[i-1], -zscore.exit, col = \"green\")\n      signal[i] <- 0\n    }\n    # End short position\n    if(units.pos[i]==0 && units.pos[i-1]==-1 && (timestamps[i] - timestamps[beginRect]) < max.duration){\n      rect(timestamps[beginRect], zscore.exit, timestamps[i-1], lim[4]+2, col = \"red\")\n      signal[i] <- 0\n    }\n  }\n  \n  if(units.pos[pos.length] == 1 && units.pos[pos.length-1] == 1 && (timestamps[pos.length] - timestamps[beginRect]) < max.duration){\n    rect(timestamps[beginRect], lim[3]-1, timestamps[pos.length], -zscore.exit, col = \"green\")\n  }else if(units.pos[pos.length] == -1 && units.pos[pos.length-1] == -1 && (timestamps[pos.length] - timestamps[beginRect]) < max.duration){\n    rect(timestamps[beginRect], zscore.exit, timestamps[pos.length], lim[4]+2, col = \"red\")\n  }\n  lines(timestamps, zscore.spread)\n  abline(h=c(-zscore.entry,zscore.entry,-zscore.exit,zscore.exit,0),col=c(\"blue\",\"blue\",\"red\",\"red\",\"green\"))\n  \n  xts(na.locf(signal), order.by = timestamps)\n}\n\n\n\n",
    "created" : 1456594230794.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4137655425",
    "id" : "2F30081B",
    "lastKnownWriteTime" : 1456594245,
    "path" : "D:/百度云/My Box Files/SAIF/论文/2016/Code/PairsTradingForRLWK0.2/PairTrading.R",
    "project_path" : "PairTrading.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}