{
    "contents" : "JohansenTest <- function(formula){\n  prices <- model.frame(formula)\n  # browser()\n  varest <- VAR(prices,p=1,type=\"const\",lag.max=24, ic=\"SC\")\n  # in the Johansen procedure for cointegration a lagged VAR (VECM) is used. Hence we need to subtract 1 from the optimal VAR lag length.\n  lagLength <- max(2,varest$p-1)\n  \n  # Perform Johansen procedure for cointegration\n  # Allow intercepts in the cointegrating vector: data without zero mean\n  # Use trace statistic (null hypothesis: number of cointegrating vectors <= r)\n  res <- ca.jo(prices,type=\"trace\",ecdet=\"const\",K=lagLength,spec=\"longrun\")\n  coef <- res@V[1:2,which.max(res@lambda)]\n  coef <- coef/coef[1]\n  return(list(coef=c(0, coef[2])))\n}\n\nlibrary(pracma)\n\nGetAssetsData <- function(market.name, assets.id, date.duration){\n  asset1.price <- GetBar(market.name, assets.id[1], '1d', date.duration[1], date.duration[2],ip=\"127.0.0.1\")\n  asset2.price <- GetBar(market.name, assets.id[2], '1d', date.duration[1], date.duration[2],ip=\"127.0.0.1\")\n  price.pair <- cbind(Cl(asset1.price), Cl(asset2.price))\n  price.pair\n}\n\nPerformTLS <- function(formula){\n  prices <- model.frame(formula)\n  # odregress(x, y)\n  odr <- odregress(prices[,2], prices[,1])\n  #   browser()\n  coef <- list(coef=c(odr$coeff[2],odr$coeff[1]))\n  return(coef)\n}\n\nPlotZscore <- function(zscore){}\n\nPlotResult2 <- function(roll.res, is.beta.fixed){\n  pair.spread <- na.omit(roll.res$spread)\n  pair.hedgeratio <- na.omit(roll.res$hedge.ratio)\n  pair.premium <- na.omit(roll.res$premium)\n  price.timestamp <- index(pair.premium)\n  price.zscore <- na.omit(roll.res$zscore)\n  #   res <- na.omit(roll.res)\n  # price.timestamp <- index(res)\n  #   dygraph(res) %>% \n  #     dySeries('spread', label = 'spread', color='black') %>% \n  #     dySeries('hedge.ratio', label='Beta', color='red') %>% \n  #     dySeries('premium', label='Alpha', color='blue') %>% \n  #     dySeries('zscore', label='zscore', color='green') %>% \n  #     dyLimit(limit = -params.entryZscore, color = 'red', strokePattern = 'solid') %>% \n  #     dyLimit(limit = params.entryZscore, color = 'red', strokePattern = 'solid')\n  #   \n  rp <- na.omit(roll.res$rp)\n  dev.new()\n  par(mfrow=c(2,3))\n  # Plot price pair\n  #   plot(price.pair[,1], type='l', ylim=c(min(price.pair), max(price.pair)) )\n  #   lines(price.pair[,2], col='red')\n  #   lines(pair.spread, col='green')\n  plot(pair.spread, type='l', main='Spread')\n  # Plot Zscore\n  # signal <- SignalWithZscore2(price.zscore, params.entryZscore, params.exitZscore, params.stoplossZscore)\n  signal <- SignalWithoutPlot(price.zscore, params.entryZscore, params.exitZscore, params.stoplossZscore)\n  # signal <- xts(signal, order.by = price.timestamp)\n  \n  # Plot return\n  if(is.beta.fixed){\n    return.pairtrading <- ReturnWithFiexdBeta(price.pair, lag(signal), lag(pair.hedgeratio))\n  }else{\n    return.pairtrading <- Return(price.pair, lag(signal), lag(pair.hedgeratio))\n  }\n  \n  pair.return <- return.pairtrading$pair.return\n  # browser()\n  #   plot(roll.res$zscore[152:178], type='l')\n  #   par(new=T)\n  #   cum.return <- cumprod(1 + pair.return[2:27])\n  #   plot(cum.return, type='l', axes = F, col='blue')\n  #   axis(4,ylim=(c(min(cum.return), max(cum.return))))\n  \n  \n  \n  #   weight.pair <- return.pairtrading$weight\n  #   plot(weight.pair[,1], type = 'l', main='weight', ylim=c(min(weight.pair), max(weight.pair)))\n  #   lines(weight.pair[,2], col='blue')\n  #   legend('topright', legend = c('price1', 'price2'), col = c('black', 'blue'), lty = c(1))\n  \n  #   info <- vector(mode = 'numeric', length = length(signal))\n  #   info[signal-lag(signal)>0] <- 1\n  #   info[signal-lag(signal)<0] <- -1\n  #   \n  #   for(i in c(1:length(signal))){\n  #     if(info[i] == 1){\n  #       print(paste('Long:', roll.res[index(signal[i])], price.pair[index(signal[i])], sep = ''))\n  #     }else if(info[i] == -1){\n  #       print(paste('Short:', roll.res[index(signal[i])], price.pair[index(signal[i])], sep = ''))\n  #     }\n  #   }\n  # browser()\n  #   price.weight.spread <- xts(rowSums(weight.pair*price.pair), order.by = index(weight.pair))\n  #   plot(price.weight.spread, type='l', main='Weight Price')\n  #   lim <- par(\"usr\")\n  #   beginRect=1\n  #   endRect=1\n  #   pos.length <- nrow(weight.pair)\n  #   timestamps <- index(weight.pair)\n  #   # browser()\n  #   for(i in 2:(pos.length-1))\n  #   {\n  #     # Begin long position\n  #     if(weight.pair[i,2]>0 && weight.pair[i-1,2]<=0)\n  #       beginRect=i\n  #     # Begin short position\n  #     if(weight.pair[i,2]<0 && weight.pair[i-1,2]>=0)\n  #       beginRect=i\n  #     \n  #     # End long position\n  #     if(weight.pair[i,2]<=0 && weight.pair[i-1,2]>0)\n  #       rect(timestamps[beginRect], lim[3]-1, timestamps[i-1], lim[4]+2, col = \"green\")\n  #     # End short position\n  #     if(weight.pair[i,2]>=0 && weight.pair[i-1,2]<0)\n  #       rect(timestamps[beginRect], lim[3]-1, timestamps[i-1], lim[4]+2, col = \"red\")\n  #   }\n  #   \n  #   if(weight.pair[pos.length,2] > 0 && weight.pair[pos.length-1,2] > 0){\n  #     rect(timestamps[beginRect], lim[3]-1, timestamps[pos.length], lim[4]+2, col = \"green\")\n  #   }else if(weight.pair[pos.length,2] < 0 && weight.pair[pos.length-1,2] < 0){\n  #     rect(timestamps[beginRect], lim[3]-1, timestamps[pos.length], lim[4]+2, col = \"red\")\n  #   }\n  #   lines(price.weight.spread)\n  \n  # Plot beta & premium\n  PlotBetaAndPremium(pair.hedgeratio, pair.premium)\n  \n  #   browser()\n  #   pair.return.correct <- rowSums(50*cumprod(1+pair.return))\n  #   plot(cumsum(pair.return), type='l')\n  \n}\n\nPlotBetaAndPremium <- function(beta, premium){\n  premium.max <- max(premium)\n  premium.min <- min(premium)\n  hedgeratio.max <- max(beta)\n  hedgeratio.min <- min(beta)\n  \n  plot(beta, type = \"l\", main = \"beta & alpha\", ylim = c(hedgeratio.min, hedgeratio.max))\n  par(new=T)\n  plot(premium, type = \"l\", axes = F, col='blue', main=NULL)\n  axis(4, ylim=c(premium.min, premium.max))\n  legend('topright', legend = c('beta(left)', 'premium(right)'), col = c('black', 'blue'), lty = 1)\n}\n\n# params: entry, exit, stoploss, period\nReturnFunction2 <- function(price.pair, params){\n  ols.params <- EstimateParametersHistorically(price.pair, period = params[4], method = lm)\n  pair.spread <- na.omit(ols.params$spread)\n  pair.hedgeratio <- na.omit(ols.params$hedge.ratio)\n  pair.premium <- na.omit(ols.params$premium)\n  price.timestamp <- index(pair.premium)\n  price.zscore <- na.omit(ols.params$zscore)\n  signal <- SignalWithoutPlot(price.zscore, params[1], params[2], params[3])\n  ret <- Return(price.pair, lag(signal), lag(pair.hedgeratio), price.timestamp)\n  last(cumprod(1 + ret))\n}\n\nParamOptimPlot <- function(price.pair){\n  # entryZscore\n  x <- seq(0.2, 1.5, 0.1)\n  # exitZscore\n  y <- seq(0, 0.5, 0.1)\n  # period\n  k <- seq(180, 300, 10)\n  # stoplossZscore\n  s <- seq(3, 5, 0.1)\n  param.frame <- data.frame(entry=rep(x, each=length(k)), period=rep(k, length(x)))\n  res <- matrix(nrow = length(x), ncol = length(k))\n  cl <- makePSOCKcluster(2)\n  registerDoParallel(cl)\n  \n  # 170 2.2 1.62\n  X<-foreach(i=1:nrow(param.frame), .combine='c', .packages = c('tseries', 'xts', 'quantmod', 'PerformanceAnalytics'), .export = c('ReturnFunction', 'EstimateParametersHistorically', 'EstimateParameters', 'SignalWithZscore2', 'Return', '.return', 'HedgeRatio2Weight')) %dopar%{\n    as.numeric(ReturnFunction(price.pair, c(param.frame[i, 1], 0, 3, param.frame[i, 2])))\n  }\n  \n  stopCluster(cl)\n  #   for(l in 1:length(k)){\n  #     for(i in 1:length(x)){\n  # #       for(j in 1:length(y)){\n  #         z <- as.numeric(ReturnFunction(price.pair, c(x[i], 0, 3, k[l])))\n  #         res[i, l] <- z\n  #       # }\n  #     }\n  #   }\n  #   res <- matrix(X, nrow = length(x))\n  #   plot_ly(x=x, y=k, z=res, type='surface')\n  list(x, k, X)\n}\n\nParamOptimization <- function(price.pair){\n  theta <- c(params.entryZscore, params.exitZscore, params.stoplossZscore)\n  ReturnFunction <- function(price.pair, params){\n    ols.params <- EstimateParametersHistorically(price.pair, period = params[4], method = lm)\n    pair.spread <- na.omit(ols.params$spread)\n    pair.hedgeratio <- na.omit(ols.params$hedge.ratio)\n    pair.premium <- na.omit(ols.params$premium)\n    price.timestamp <- index(pair.premium)\n    ols.params <- cbind(pair.spread, pair.hedgeratio,pair.premium)\n    \n    meanSpread <- mean(ols.params$spread)\n    stdSpread <- sd(ols.params$spread)\n    \n    zScore = (ols.params$spread - meanSpread) / stdSpread\n    signal <- SignalWithZscore2(zScore, params[1], params[2], params[3])\n    ret <- Return(price.pair, lag(signal), lag(pair.hedgeratio), price.timestamp)\n    browser()\n    return(last(cumprod(1 + ret)))\n  }\n  GradientFunction <- function(params){\n    params-c(0.2, -0.1, 0)\n  }\n  #   constrOptim(theta = theta, f = ReturnFunction, grad = GradientFunction, ui = matrix(c(),), ci = c())\n  #   optim(par = theta, fn = ReturnFunction, gr = GradientFunction, control = list(fnscale=-1), method = 'L-BFGS-B', upper = c(300, 2.5, 0.5, 4), lower = c(100, 1, 0, 3))\n  optim(par = theta, fn = ReturnFunction, control = list(fnscale=-1))\n}\n\n# deprecated\n# calculate zscore with whole price.pair\nPlotResult <- function(params, price.pair, is.beta.fixed){\n  # create & plot trading signals\n  # params$spread <- na.locf(params$spread, na.rm=TRUE)\n  pair.spread <- na.omit(params$spread)\n  pair.hedgeratio <- na.omit(params$hedge.ratio)\n  pair.premium <- na.omit(params$premium)\n  price.timestamp <- index(pair.premium)\n  params <- cbind(pair.spread, pair.hedgeratio, pair.premium)\n  \n  meanSpread <- mean(params$spread)\n  stdSpread <- sd(params$spread)\n  \n  zScore = (params$spread - meanSpread) / stdSpread\n  dev.new()\n  par(mfrow=c(2,2))\n  plot(price.pair[,1], type='l', ylim=c(min(price.pair), max(price.pair)) )\n  lines(price.pair[,2], col='red')\n  signal <- SignalWithZscore2(zScore, params.entryZscore, params.exitZscore, params.stoplossZscore)\n  premium.max <- max(pair.premium)\n  premium.min <- min(pair.premium)\n  hedgeratio.max <- max(pair.hedgeratio)\n  hedgeratio.min <- min(pair.hedgeratio)\n  plot(params$hedge,type = \"l\", main = \"hedge & alpha\", ylim = c(min(premium.min, hedgeratio.min), max(premium.max, hedgeratio.max)))\n  lines(params$premium,type = \"l\",col = \"blue\")\n  if(is.beta.fixed){\n    return.pairtrading <- ReturnWithFiexdBeta(price.pair, lag(signal), lag(params$hedge.ratio), price.timestamp)\n  }else{\n    return.pairtrading <- Return(price.pair, lag(signal), lag(params$hedge.ratio), price.timestamp)\n  }\n  plot(100 * cumprod(1 + return.pairtrading))\n}\n# deprecated\n# params = entry, exit, stoploss, period\nReturnFunction <- function(price.pair, params){\n  ols.params <- EstimateParametersHistorically(price.pair, period = params[4], method = lm)\n  pair.spread <- na.omit(ols.params$spread)\n  pair.hedgeratio <- na.omit(ols.params$hedge.ratio)\n  pair.premium <- na.omit(ols.params$premium)\n  price.timestamp <- index(pair.premium)\n  ols.params <- cbind(pair.spread, pair.hedgeratio,pair.premium)\n  \n  meanSpread <- mean(ols.params$spread)\n  stdSpread <- sd(ols.params$spread)\n  \n  zScore = (ols.params$spread - meanSpread) / stdSpread\n  signal <- SignalWithZscore2(zScore, params[1], params[2], params[3])\n  ret <- Return(price.pair, lag(signal), lag(pair.hedgeratio), price.timestamp)\n  last(cumprod(1 + ret))\n  # SharpeRatio(ret, FUN='StdDev')\n}\n",
    "created" : 1456594345997.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2299729127",
    "id" : "C20DBD76",
    "lastKnownWriteTime" : 1456594101,
    "path" : "D:/百度云/My Box Files/SAIF/论文/2016/Code/PairsTradingForRLWK0.2/func.R",
    "project_path" : "func.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}